go(
    range(10),
    map(a => a + 10),
    filter(a => a % 2),
    take(2),
    log
); // [11, 13]

go(
    L.range(10),
    L.map(a => a + 10),
    L.filter(a => a % 2),
    take(2),
    log
); // [11, 13]

실행순서가 첫번째 경우는 10개짜리로 range가 배열 '전부' 생성
맵도 '전부' 10개를 순회하며 10더함
'전부' 필터가 순회하며 홀수를 고름
take가 2개를 자름
가만히 생각해보면 시간복잡도 상으로 꽤 불리하다는 것을 알 수 있는데
해당 코드를 그냥 명령형으로 작성하면 이렇게 작성할리 없다는 것을 생각하면 된다.
take에서 어차피 2개가 짤리기 때문에 range에서부터 2개만 계산되도록 하는게 일반적이지 않나?

따라서 두번째 방법이 함수형 프로그래밍에서 시간복잡도에 밑지지 않는 방법이라고 볼 수 있다.
지연 평가를 통해서 실행되는 이 방법은
L.range -> L.map -> L.filter -> take 순으로 적혀있지만 실제로는
L.range를 비롯한 지연 평가 함수 3개에서 평가를 제너레이터를 통해서 미루고 take에서 첫번째 값을 요구하게 된다.
여기서 take가 가지고 있는 이터레이터는 L.filter 제너레이터가 준 이터레이터 이며 또 이게 가지고 있는 이터레이터는 L.map
L.map에서 가지고 있는 이터레이터는 L.range의 이터레이터이기 때문에 서로 지연된 상황에서 차례로(아래에서 위로) 값을 요구하게 되며
결국 L.range에서 첫번째 값 0을 반환하게 된다.

그러면 첫번째 값 0을 요구한 것은 L.map이니까 10을 더해서 바로 L.filter에게 줄것이고 또 여기서 10은 홀수가 아니기 때문에 L.filter에서
yield를 하지 못했으므로 여전히 take의 for ...of 에서는 기다리고 있는 상황이고
L.filter는 바로 다음 값을 L.map에 요청, L.range에서 1이 나오고 1은 11이되어 
L.filter가 받아 비로소 yield를 하여 take가 받을 수 있을 것 이다.
이렇게 take의 첫번째 값 11이 저장되고 이어서 두번째값에 대한 요청을 위와 같이 반복한다.

즉 여기서 가장 중요한 점은 어쨌든 지연 평가를 사용함으로써 딲 2개만 각 함수들에서 계산될 수 있도록 되어있다는 것이 특징이고
이로인해서 시간복잡도의 단축을 이룰 수 있다.